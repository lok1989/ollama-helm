#!/bin/ksh

# Validate PROFILE is passed
if [[ -z "$PROFILE" ]]; then
  echo "ERROR: PROFILE environment variable not set. Must be 'UAT' or 'PROD'."
  exit 1
fi

# Directory to scan
OUTGOING_DIR="/data/outgoing"

# Path to SSH private key
KEY_PATH="$HOME/.ssh/id_rsa"

# Initialize destination map with user@host|remote_path
typeset -A DEST_MAP

if [[ "$PROFILE" == "UAT" ]]; then
  DEST_MAP["INV_"]="uat_user1@sftp.uat-acme.com|/remote/uat/invoices"
  DEST_MAP["PAY_"]="uat_user2@sftp.uat-beta.com|/remote/uat/payments"
  DEST_MAP["LOG_"]="uat_user3@sftp.uat-gamma.com|/remote/uat/logs"

elif [[ "$PROFILE" == "PROD" ]]; then
  DEST_MAP["INV_"]="prod_user1@sftp.prod-acme.com|/remote/prod/invoices"
  DEST_MAP["PAY_"]="prod_user2@sftp.prod-beta.com|/remote/prod/payments"
  DEST_MAP["LOG_"]="prod_user3@sftp.prod-gamma.com|/remote/prod/logs"

else
  echo "ERROR: Invalid PROFILE '$PROFILE'. Expected 'UAT' or 'PROD'."
  exit 2
fi

# Timestamp function
timestamp() {
  date '+%Y-%m-%d %H:%M:%S'
}

# Process each file
for FILE in "$OUTGOING_DIR"/*; do
  [[ -f "$FILE" ]] || continue  # Skip non-regular files
  BASENAME=$(basename "$FILE")
  SENT=0

  for PATTERN in "${!DEST_MAP[@]}"; do
    if [[ "$BASENAME" == ${PATTERN}* ]]; then
      DEST_INFO="${DEST_MAP[$PATTERN]}"
      DEST_HOST=$(echo "$DEST_INFO" | cut -d'|' -f1)
      DEST_DIR=$(echo "$DEST_INFO" | cut -d'|' -f2)

      echo "[$(timestamp)] [$PROFILE] Transferring $BASENAME to $DEST_HOST:$DEST_DIR..."

      SFTP_OUTPUT=$(sftp -i "$KEY_PATH" "$DEST_HOST" 2>&1 <<EOF
cd "$DEST_DIR"
put "$FILE"
EOF
)
      EXIT_CODE=$?

      if [[ $EXIT_CODE -eq 0 ]]; then
        echo "[$(timestamp)] [$PROFILE] SUCCESS: $BASENAME transferred to $DEST_HOST:$DEST_DIR"
        SENT=1
        break
      else
        if echo "$SFTP_OUTPUT" | grep -qi "Permission denied\|Authentication failed"; then
          echo "[$(timestamp)] [$PROFILE] AUTH ERROR: Authentication failed for $DEST_HOST"
        else
          echo "[$(timestamp)] [$PROFILE] ERROR: Transfer failed for $BASENAME to $DEST_HOST:$DEST_DIR"
          echo "[$(timestamp)] [$PROFILE] SFTP output:"
          echo "$SFTP_OUTPUT"
        fi
      fi
    fi
  done

  if [[ $SENT -eq 0 ]]; then
    echo "[$(timestamp)] [$PROFILE] SKIPPED: No matching destination for $BASENAME"
  fi
done





String filter = "";
String whereClause = "";

// Check and extract filters
if (request.getFilters() != null && request.getFilters().length > 0) {
    List<RunQueryRequest.Filter> filters = List.of(request.getFilters());
    filter = filters.get(0).getFilters();

    // Case-insensitive check and parse for firmCd
    if (filter != null && filter.toLowerCase().contains("[firmcd] equals")) {
        String[] parts = filter.split("(?i)equals");  // (?i) = case-insensitive
        if (parts.length == 2) {
            String fieldName = parts[0].replace("[", "").replace("]", "").trim();  // e.g., firmCd
            String value = parts[1].trim();  // e.g., 01
            if (!fieldName.isEmpty() && !value.isEmpty()) {
                whereClause = " WHERE " + fieldName.toUpperCase() + " = '" + value + "'";
            }
        }
    }
}

// Build the final SQL query
String sql = "SELECT * FROM ARCHIVE." +
             whereClause +
             " LIMIT " + request.getPageSize() +
             " OFFSET " + (request.getPage() * request.getPageSize());

SqlFieldsQuery query = new SqlFieldsQuery(sql);
===========================



  public static String formatName(String input) {
        if (input == null || input.isEmpty()) {
            return input;
        }

        // Split the string by underscores
        String[] parts = input.toLowerCase().split("_");
        StringBuilder formattedName = new StringBuilder();

        for (String part : parts) {
            if (!part.isEmpty()) {
                // Capitalize the first letter of each part and append to the result
                formattedName
                    .append(Character.toUpperCase(part.charAt(0)))
                    .append(part.substring(1))
                    .append(" ");
            }
        }

        // Trim trailing space
        return formattedName.toString().trim();
    }
